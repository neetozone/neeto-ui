import { isPresent, snakeToCamelCase, camelToSnakeCase } from "neetocist";nimport { __, all, equals, filter, includes, pipe, pluck } from "ramda";nnimport {n  CellContent,n  HeaderCell,n  ReorderableHeaderCell,n  ResizableHeaderCell,n} from "./components/HeaderCell";nimport {n  COLUMN_FIXED_VALUES,n  SELECT_ALL_ROWS_CALLOUT_DESKTOP_HEIGHT,n  SELECT_ALL_ROWS_CALLOUT_MOBILE_HEIGHT,n  TABLE_SORT_ORDERS,n  TABLE_PAGINATION_HEIGHT,n  TABLE_ROW_HEIGHT,n} from "./constants";nn// Column width constantsnexport const MIN_COLUMN_WIDTH = 80;nexport const DEFAULT_COLUMN_WIDTH = 150;nnconst convertLocationPathnameToId = () => {n  const pathname = decodeURIComponent(window.location.pathname).replace(n    /^//,n    ""n  );nn  let hash = 0;n  for (let i = 0; i < pathname.length; i++) {n    const char = pathname.charCodeAt(i);n    hash = (hash << 5) - hash + char;n    hash = hash & hash; // Convert to 32-bit integern  }nn  return Math.abs(hash).toString(16).toUpperCase();n};nnexport const getHeaderCell = ({ enableColumnResize, enableColumnReorder }) => {n  if (enableColumnReorder && enableColumnResize) return { cell: HeaderCell };nn  if (enableColumnResize) return { cell: ResizableHeaderCell };nn  if (enableColumnReorder) return { cell: ReorderableHeaderCell };nn  return { cell: CellContent };n};nnexport const isIncludedIn = (array1, array2) =>n  all(includes(__, array1), array2);nnexport const getSelectAllRowsCalloutHeight = () =>n  window.innerWidth < 768n    ? SELECT_ALL_ROWS_CALLOUT_MOBILE_HEIGHTn    : SELECT_ALL_ROWS_CALLOUT_DESKTOP_HEIGHT;nnexport const sortFrozenColumns = columnData => {n  const originalIndices = new Map(n    columnData.map((col, index) => [col.dataIndex, index])n  );nn  return (a, b) => {n    const aFixed = isPresent(a.fixed);n    const bFixed = isPresent(b.fixed);n    const aIndex = originalIndices.get(a.dataIndex);n    const bIndex = originalIndices.get(b.dataIndex);nn    if (aFixed !== bFixed) return aFixed ? -1 : 1;nn    if (aIndex - bIndex) return aIndex - bIndex;nn    return 0;n  };n};nnexport const getFixedColumns = columnData =>n  pipe(n    filter(({ fixed }) => isPresent(fixed)),n    pluck("dataIndex")n  )(columnData);nnexport const getColumnSortOrder = (col, sortedInfo) =>n  equals(sortedInfo.field, col.dataIndex) || equals(sortedInfo.field, col.key)n    ? sortedInfo.ordern    : null;nnexport const getColumFixedValue = (col, frozenColumns) =>n  frozenColumns?.indexOf(col.dataIndex) !== -1n    ? COLUMN_FIXED_VALUES.LEFTn    : null;nnexport const getFrozenColumnsLocalStorageKey = localStorageKeyPrefix => {n  const prefix = isPresent(localStorageKeyPrefix)n    ? localStorageKeyPrefixn    : convertLocationPathnameToId();nn  return `NEETOUI-${prefix}-FIXED_COLUMNS`;n};nnexport const getSortInfoFromQueryParams = queryParams => {n  const sortedInfo = {};n  if (n    isPresent(queryParams.sort_by) &&n    isPresent(queryParams.order_by) &&n    isPresent(TABLE_SORT_ORDERS[queryParams.order_by])n  ) {n    sortedInfo.field = queryParams.sort_by.includes("+")n      ? queryParams.sort_by.split("+").map(snakeToCamelCase)n      : snakeToCamelCase(queryParams.sort_by);n    sortedInfo.order = TABLE_SORT_ORDERS[queryParams.order_by];n  }nn  return sortedInfo;n};nnexport const getSortField = field => {n  if (Array.isArray(field)) {n    return field.map(camelToSnakeCase).join("+");n  }nn  return camelToSnakeCase(field);n};nnexport const calculateRowsPerPage = () => {n  const viewportHeight = window.innerHeight;n  const rowsPerPage = Math.floor(n    ((viewportHeight - TABLE_PAGINATION_HEIGHT) / TABLE_ROW_HEIGHT) * 3n  );nn  return Math.ceil(rowsPerPage / 10) * 10;n};nn// New utility functions for column width managementnexport const validateColumnWidth = (width) => {n  const numWidth = typeof width === 'number' ? width : DEFAULT_COLUMN_WIDTH;n  return Math.max(numWidth, MIN_COLUMN_WIDTH);n};nnexport const calculateTotalTableWidth = (columns) => {n  return columns.reduce((total, col) => {n    const width = col.width || DEFAULT_COLUMN_WIDTH;n    return total + validateColumnWidth(width);n  }, 0);n};nnexport const normalizeColumnWidths = (columns) => {n  return columns.map(col => ({n    ...col,n    width: validateColumnWidth(col.width),n  }));n};nnexport const isColumnAtMinimumWidth = (column) => {n  const width = column.width || DEFAULT_COLUMN_WIDTH;n  return width <= MIN_COLUMN_WIDTH;n};nnexport const canResizeColumn = (column, direction = 'shrink') => {n  if (direction === 'shrink') {n    return !isColumnAtMinimumWidth(column);n  }n  return true; // Can always expandn};